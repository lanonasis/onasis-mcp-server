# API Key Hashing Fixes - Technical Deep Dive

## Problem Overview

The Onasis MCP Server had **three incompatible hashing methods** for API keys across different components, preventing proper API key validation:

1. **External API Keys (auth-aligned.ts)**: Used **bcrypt** hashing (salted, slow)
2. **Dashboard/Client**: Sent keys in **plain text**
3. **Database**: Expected **SHA-256** hashes (one-way, fast)

This mismatch caused API keys generated by one system to fail validation in another.

---

## Root Cause Analysis

### The Incompatibility Issue

**bcrypt** is a salted hashing algorithm - each hash operation produces a different result even for the same input:
```javascript
bcrypt.hash("my-api-key", 10) // → $2a$10$abc123...
bcrypt.hash("my-api-key", 10) // → $2a$10$xyz789... (different!)
```

**SHA-256** is deterministic - same input always produces the same hash:
```javascript
sha256("my-api-key") // → e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
sha256("my-api-key") // → e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 (same!)
```

### Why This Broke Authentication

1. **Generation Flow** (Dashboard/Client):
   ```
   User generates key → "sk_prod_abc123..." → Sent to backend
   ```

2. **Storage Flow** (Backend):
   ```
   Backend receives plain key → Hashes with bcrypt → Stores in DB
   But DB expected SHA-256 hash!
   ```

3. **Validation Flow** (auth-aligned.ts):
   ```
   Client sends key → "sk_prod_abc123..."
   Backend hashes with bcrypt → Compares to DB
   MISMATCH: bcrypt hash ≠ SHA-256 hash (or bcrypt hash ≠ bcrypt hash due to salt)
   ```

---

## Solution: Unified SHA-256 Hashing

### Why SHA-256?

1. **Deterministic**: Same input always produces same output
2. **Fast**: Suitable for API authentication (no artificial slowdown needed)
3. **Secure**: One-way function, 256-bit output, cryptographically secure
4. **Standard**: Built into Node.js crypto module, no external dependencies

### Implementation Changes

#### 1. External API Keys (auth-aligned.ts)

**Before** (bcrypt):
```typescript
async function authenticateApiKey(apiKey: string): Promise<AlignedUser | null> {
  // ❌ Hash the incoming key with bcrypt (creates NEW hash each time)
  const hashedApiKey = await bcrypt.hash(apiKey, 10);
  
  // ❌ Query by... nothing? This was broken
  const { data: keyRecord } = await supabase
    .from('maas_api_keys')
    .select('*')
    .eq('is_active', true)
    .single();
  
  // ❌ Compare hashed key to stored hash (different salts = always fails)
  const isValidKey = await bcrypt.compare(apiKey, keyRecord.key_hash);
}
```

**After** (SHA-256):
```typescript
async function authenticateApiKey(apiKey: string): Promise<AlignedUser | null> {
  // ✅ Hash the incoming key with SHA-256 (deterministic)
  const hashedApiKey = crypto.createHash('sha256').update(apiKey).digest('hex');
  
  // ✅ Query by the hash
  const { data: keyRecord } = await supabase
    .from('maas_api_keys')
    .select('*')
    .eq('key_hash', hashedApiKey)
    .eq('is_active', true)
    .single();
  
  // ✅ Direct hash comparison (SHA-256 is deterministic)
  if (!keyRecord) return null; // No additional comparison needed
}
```

#### 2. Internal API Keys (auth.ts)

**New Function Added**:
```typescript
async function validateInternalApiKey(apiKey: string): Promise<UnifiedUser | null> {
  // ✅ Hash with SHA-256
  const hashedApiKey = crypto.createHash('sha256').update(apiKey).digest('hex');
  
  // ✅ Query stored_api_keys table
  const { data: keyRecord } = await supabase
    .from('stored_api_keys')
    .select('*')
    .eq('encrypted_value', hashedApiKey)
    .eq('status', 'active')
    .single();
  
  if (!keyRecord) return null;
  
  // ✅ Check expiration
  if (keyRecord.expires_at && new Date() > new Date(keyRecord.expires_at)) {
    return null;
  }
  
  return unifiedUser;
}
```

#### 3. Enhanced authMiddleware (auth.ts)

**New Flow**:
```typescript
export const authMiddleware = async (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  
  if (apiKey) {
    // ✅ Try internal API key validation first
    const user = await validateInternalApiKey(apiKey);
    
    if (user) {
      req.user = user;
      next();
      return;
    }
    
    // ✅ Fall back to external passthrough
    req.user = { apiKey: apiKey }; // Pass to external validator
    next();
    return;
  }
  
  // Handle JWT tokens...
}
```

---

## Database Schema Requirements

### External API Keys Table (maas_api_keys)

```sql
CREATE TABLE maas_api_keys (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  key_hash TEXT NOT NULL, -- SHA-256 hash (64 hex characters)
  key_prefix TEXT, -- e.g., "sk_prod_" for display
  is_active BOOLEAN DEFAULT true,
  expires_at TIMESTAMPTZ,
  last_used TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  
  -- Index for fast lookups
  UNIQUE(key_hash)
);

CREATE INDEX idx_maas_api_keys_hash ON maas_api_keys(key_hash);
CREATE INDEX idx_maas_api_keys_user ON maas_api_keys(user_id);
```

### Internal API Keys Table (stored_api_keys)

```sql
CREATE TABLE stored_api_keys (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  encrypted_value TEXT NOT NULL, -- SHA-256 hash for internal keys
  key_type TEXT, -- 'api_key', 'database_url', etc.
  environment TEXT, -- 'development', 'staging', 'production'
  organization_id UUID NOT NULL,
  project_id UUID,
  created_by UUID,
  status TEXT DEFAULT 'active', -- 'active', 'rotating', 'deprecated', 'expired'
  access_level TEXT, -- 'public', 'authenticated', 'team', 'admin'
  expires_at TIMESTAMPTZ,
  last_used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  
  -- Index for fast lookups
  UNIQUE(encrypted_value)
);

CREATE INDEX idx_stored_api_keys_hash ON stored_api_keys(encrypted_value);
CREATE INDEX idx_stored_api_keys_org ON stored_api_keys(organization_id);
CREATE INDEX idx_stored_api_keys_status ON stored_api_keys(status);
```

---

## Security Improvements

### Before (Insecure)

- ❌ Bcrypt hashing created new salts each time
- ❌ Impossible to query by hash (no deterministic comparison)
- ❌ Plain text keys transmitted without hashing before storage
- ❌ No expiration checking
- ❌ No revocation support
- ❌ No audit trails

### After (Secure)

- ✅ SHA-256 hashing is deterministic and secure
- ✅ Direct hash-based queries (indexed for performance)
- ✅ Keys hashed immediately upon receipt
- ✅ Expiration checking enforced
- ✅ Status-based revocation (`status = 'active'`)
- ✅ Last-used tracking for audit trails
- ✅ Separate internal and external key systems

---

## Migration Notes

### For Existing Keys

If you have existing API keys stored with bcrypt hashes:

1. **Option A: Forced Regeneration** (Recommended)
   - Mark all existing keys as `status = 'deprecated'`
   - Force users to regenerate keys
   - New keys will use SHA-256

2. **Option B: Migration Script**
   ```typescript
   // Not recommended - requires storing plain keys temporarily
   // Better to force regeneration
   ```

3. **Option C: Grace Period**
   - Support both bcrypt and SHA-256 for 30 days
   - Gradually migrate users
   - Deprecate bcrypt support after grace period

### Database Migration

```sql
-- 1. Add new column for SHA-256 hashes
ALTER TABLE maas_api_keys ADD COLUMN key_hash_sha256 TEXT;

-- 2. Create index
CREATE UNIQUE INDEX idx_maas_api_keys_sha256 ON maas_api_keys(key_hash_sha256);

-- 3. Mark old keys as deprecated
UPDATE maas_api_keys 
SET status = 'deprecated' 
WHERE key_hash_sha256 IS NULL;

-- 4. After all users migrate, drop old column
ALTER TABLE maas_api_keys DROP COLUMN key_hash;
ALTER TABLE maas_api_keys RENAME COLUMN key_hash_sha256 TO key_hash;
```

---

## Testing Checklist

### Unit Tests

- [ ] SHA-256 hashing produces correct output
- [ ] Same input produces same hash
- [ ] Invalid keys are rejected
- [ ] Expired keys are rejected
- [ ] Inactive keys are rejected

### Integration Tests

- [ ] External API key validation works
- [ ] Internal API key validation works
- [ ] JWT token validation still works
- [ ] Fallback to external passthrough works
- [ ] Expiration enforcement works

### End-to-End Tests

- [ ] Generate API key via dashboard
- [ ] Use API key to authenticate API request
- [ ] Validate key appears in audit logs
- [ ] Revoke key and verify rejection
- [ ] Test with expired key

---

## Performance Considerations

### SHA-256 vs Bcrypt

| Metric | SHA-256 | Bcrypt |
|--------|---------|--------|
| Speed | ~1-2ms | ~100-200ms |
| Use Case | API authentication | Password storage |
| Deterministic | Yes | No (salted) |
| Reversible | No | No |

### Query Performance

With proper indexing:
```sql
-- Fast lookup (indexed)
SELECT * FROM maas_api_keys WHERE key_hash = $1;

-- Execution time: ~1-2ms
```

---

## Code References

### Modified Files

1. **src/middleware/auth-aligned.ts**
   - Lines 1-6: Import crypto instead of bcrypt
   - Lines 141-205: Rewritten `authenticateApiKey()` function

2. **src/middleware/auth.ts**
   - Lines 1-9: Added crypto and Supabase imports
   - Lines 25-93: New `validateInternalApiKey()` function
   - Lines 95-177: Enhanced `authMiddleware()` with internal key support

### New Functions

- `validateInternalApiKey(apiKey: string): Promise<UnifiedUser | null>`
  - Purpose: Validate internal API keys from stored_api_keys table
  - Method: SHA-256 hashing with database lookup
  - Checks: Expiration, status, revocation

---

## Troubleshooting

### Issue: "API key validation fails after upgrade"

**Cause**: Old keys use bcrypt, new system uses SHA-256

**Solution**: Regenerate API keys

### Issue: "Internal API keys not working"

**Cause**: `encrypted_value` column expects SHA-256 hash

**Solution**: 
1. Check if column stores SHA-256 hashes
2. Verify key format matches expected pattern
3. Check `status = 'active'`

### Issue: "External API keys not working"

**Cause**: maas_api_keys table expects `key_hash` as SHA-256

**Solution**:
1. Update client to hash before sending
2. Update backend to hash before storing
3. Verify database schema

---

## Additional Resources

- [Node.js Crypto Documentation](https://nodejs.org/api/crypto.html)
- [SHA-256 Algorithm](https://en.wikipedia.org/wiki/SHA-2)
- [API Key Security Best Practices](https://www.owasp.org/index.php/API_Key_Security)

---

**Last Updated**: 2025-11-22  
**Version**: 1.0  
**Author**: Onasis Development Team
